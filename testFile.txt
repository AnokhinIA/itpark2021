Для этого появился интерфейс Lock.
Есть Lock, с которым вы можете перезаходить, т.е. это привычный Lock.
Вы предположим выполняете некие атомарные действия, сначала забираете этот Lock вызовом метода Lock,
выполняете опредленнные действия и освобождаете его вызовом метода unlock.
=====
Callable, так скажем, является неотъемлимой частью для использования в тех же executors API.
У нас есть понятие Thread pool, в котором мы можем выполнять многопоточные tasks.
Передавая в эти executors pools instance callable мы можем получить обертки в виде future.
И соответственно, обращаясь к этому future можем получить результат, который был выполнен в этом самом callable.
